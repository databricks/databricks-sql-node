diff --git a/node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js b/node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js
index 17e0d0c..0e9bb16 100644
--- a/node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js
+++ b/node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js
@@ -17,6 +17,7 @@
  * under the License.
  */
 var util = require('util');
+var axios = require('axios')
 var http = require('http');
 var https = require('https');
 var EventEmitter = require('events').EventEmitter;
@@ -84,21 +85,20 @@ var HttpConnection = exports.HttpConnection = function(options) {
   this.protocol = this.options.protocol || TBinaryProtocol;
 
   //Prepare Node.js options
-  this.nodeOptions = {
+  this.axiosConfig = {
     host: this.host,
     port: this.port,
     socketPath: this.socketPath,
-    path: this.options.path || '/',
+    url: this.options.path || '/',
     method: 'POST',
     headers: this.options.headers || {},
-    responseType: this.options.responseType || null
   };
-  for (var attrname in this.options.nodeOptions) {
-    this.nodeOptions[attrname] = this.options.nodeOptions[attrname];
+  for (var attrname in this.options.axiosConfig) {
+    this.axiosConfig[attrname] = this.options.axiosConfig[attrname];
   }
   /*jshint -W069 */
-  if (! this.nodeOptions.headers['Connection']) {
-    this.nodeOptions.headers['Connection'] = 'keep-alive';
+  if (! this.axiosConfig.headers['Connection']) {
+    this.axiosConfig.headers['Connection'] = 'keep-alive';
   }
   /*jshint +W069 */
 
@@ -106,7 +106,7 @@ var HttpConnection = exports.HttpConnection = function(options) {
   //  calling client in multiplexed scenarios
   this.seqId2Service = {};
 
-  function decodeCallback(transport_with_data) {
+  function decodeCallback(transport_with_data, handleError) {
     var proto = new self.protocol(transport_with_data);
     try {
       while (true) {
@@ -146,10 +146,11 @@ var HttpConnection = exports.HttpConnection = function(options) {
           client['recv_' + header.fname](proto, header.mtype, dummy_seqid);
         } else {
           delete client._reqs[dummy_seqid];
-          self.emit("error",
+          handleError(
                     new thrift.TApplicationException(
                        thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
-                       "Received a response to an unknown RPC function"));
+                       "Received a response to an unknown RPC function")
+          );
         }
       }
     }
@@ -157,7 +158,7 @@ var HttpConnection = exports.HttpConnection = function(options) {
       if (e instanceof InputBufferUnderrunError) {
         transport_with_data.rollbackPosition();
       } else {
-        self.emit('error', e);
+        handleError(e);
       }
     }
   }
@@ -165,43 +166,21 @@ var HttpConnection = exports.HttpConnection = function(options) {
 
   //Response handler
   //////////////////////////////////////////////////
-  this.responseCallback = function(response) {
-    var data = [];
-    var dataLen = 0;
-
-    if (response.statusCode !== 200) {
-      this.emit("error", new THTTPException(response));
+  this.handleResponse = function(response, handleError) {
+    if (response.status !== 200) {
+      handleError(new THTTPException(response));
+      return;
     }
+    data = response.data
 
-    response.on('error', function (e) {
-      self.emit("error", e);
-    });
+    self.transport.receiver(function(transport_with_data) {
+      return decodeCallback(transport_with_data, handleError);
+    })(data)
 
     // When running directly under node, chunk will be a buffer,
     // however, when running in a Browser (e.g. Browserify), chunk
     // will be a string or an ArrayBuffer.
-    response.on('data', function (chunk) {
-      if ((typeof chunk == 'string') ||
-          (Object.prototype.toString.call(chunk) == '[object Uint8Array]')) {
-        // Wrap ArrayBuffer/string in a Buffer so data[i].copy will work
-        data.push(new Buffer(chunk));
-      } else {
-        data.push(chunk);
-      }
-      dataLen += chunk.length;
-    });
 
-    response.on('end', function(){
-      var buf = new Buffer(dataLen);
-      for (var i=0, len=data.length, pos=0; i<len; i++) {
-        data[i].copy(buf, pos);
-        pos += data[i].length;
-      }
-      //Get the receiver function for the transport and
-      //  call it with the buffer
-      self.transport.receiver(decodeCallback)(buf);
-    });
-  };
 };
 util.inherits(HttpConnection, EventEmitter);
 
@@ -212,18 +191,41 @@ util.inherits(HttpConnection, EventEmitter);
  * @event {error} the "error" event is raised upon request failure passing the
  *     Node.js error object to the listener.
  */
-HttpConnection.prototype.write = function(data) {
+HttpConnection.prototype.write = function(data, seqid) {
   var self = this;
   var opts = self.nodeOptions;
   opts.headers["Content-length"] = data.length;
   if (!opts.headers["Content-Type"])
     opts.headers["Content-Type"] = "application/x-thrift";
-  var req = (self.https) ?
-      https.request(opts, self.responseCallback) :
-      http.request(opts, self.responseCallback);
-  req.on('error', function(err) {
-    self.emit("error", err);
+
+  // The purpose of this handler is to pass an error to corresponding operation's callback if
+  // error is associated with any. If error cannot be associated with any operation, it will be
+  // emitted as 'error' event
+  function handleError(err) {
+    var client = self.client;
+    var callback = client._reqs[seqid] || function() {
+      self.emit("error", err);
+    };
+    delete client._reqs[seqid];
+    callback(err);
+  }
+
+  function responseCallback(response) {
+    return self.handleResponse(response, handleError);
+  }
+
+  var req = axios(opts).then(
+    res => responseCallback(res)
+  )
+  req.on('timeout', () => {
+    // Ignore all subsequent errors on this request
+    req.off('error', handleError);
+    req.on('error', () => {});
+    // Emit a single error and destroy request
+    handleError(new thrift.TApplicationException(thrift.TApplicationExceptionType.PROTOCOL_ERROR, 'Request timed out'));
+    req.destroy();
   });
+  req.on('error', handleError);
   req.write(data);
   req.end();
 };
